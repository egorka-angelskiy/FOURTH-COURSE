Функция MPI_UNPACK распаковывает сообщение в приемный буфер, описанный аргументами outbuf, outcount, datatype из буферного пространства, описанного аргументами inbuf и insize. Выходным буфером может быть любой коммуникационный буфер, разрешенный в MPI_RECV. Входной буфер есть смежная область памяти, содержащая insize байтов, начиная с адреса inbuf. Входное значение position есть первая ячейка во входном буфере, занятом упакованным сообщением. рosition инкрементируется размером упакованного сообщения, так что выходное значение рosition есть первая ячейка во входном буфере после ячеек, занятых сообщением, которое было упаковано. сomm есть коммуникатор для приема упакованного сообщения.

Совет пользователям: Укажем на разницу между MPI_RECV и MPI_UNPACK: в MPI_RECV аргумент count описывает максимальное число единиц, которое может быть получено. Действительное же число определяется длиной входного сообщения. В MPI_UNPACK аргумент count описывает действительное число единиц, которые распакованы; ``размер'' соответствующего сообщения инкрементируется в position. Причина для этого изменения состоит в том, что ``размер входного сообщения'' не предопределен, поскольку пользователь решает, сколько распаковывать; да и нелегко определить ``размер сообщения'' по числу распакованных единиц. Фактически в неоднородной системе это число не может быть определено априори.[]

Чтобы понять поведение pack и unpack, удобно предположить, что часть данных сообщения есть последовательность, полученная конкатенацией последующих значений, посланных в сообщении. Операция pack сохраняет эту последовательность в буферном пространстве, как при посылке сообщения в этот буфер. Операция unpack обрабатывает последовательность из буферного пространства, как при приеме сообщения из этого буфера. (Полезно вспомнить о внутренних файлах языка ФОРТРАН или о sscanf в языке Си для подобной функции).

Несколько сообщений могут быть последовательно упакованы в один упакованный объект (packing unit). Это достигается несколькими последовательными связанными обращениями к MPI_PACK, где первый вызов обеспечивает position = 0, и каждый последующий вызов вводит значение position, которое было выходом для предыдущего вызова, и то же самое значение для outbuf, outcount и comm. Этот упакованный объект теперь содержит эквивалентную информацию, которая хранилась бы в сообщении по одной передаче с буфером передачи, который является ``конкатенацией'' индивидуальных буферов передачи.




Функция широковещательной передачи MPI_BCAST посылает сообщение из корневого процесса всем процессам группы, включая себя. Она вызывается всеми процессами группы с одинаковыми аргументами для comm и root. В момент возврата управления содержимое корневого буфера обмена будет уже скопировано во все процессы.

В аргументе datatype можно задавать производные типы данных. Сигнатура типа данных count, datatype любого процесса обязана совпадать с соответствующей сигнатурой в корневом процессе. Необходимо, чтобы количество посланных и полученных данных совпадало попарно для корневого и каждого другого процессов. Такое ограничение имеют и все остальные коллективные операции, выполняющие перемещение данных. Однако по-прежнему разрешается различие в картах типов данных между отправителями и получателями.